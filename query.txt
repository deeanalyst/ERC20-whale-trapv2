analyze this folder and the contracts in the src folder to ensure the trap logic works 100% in accordance to what the Drosera Network says in their website, docs, GitHub repos, their examples in the links provided here: app.drosera.io, drosera.io, https://github.com/drosera-network/drosera-mcp-server, https://medium.com/ @droseranetwork, https://github.com/drosera-network/drosera-workshops/tree/main/workshops/intro, https://drosera.notion.site/Dev-FAQs-1d82748eb1a1809487efd7be7604d16f, https://github.com/drosera-network and these community creations: https://github.com/Warx04/RealWorldAssetTrap, https://github.com/Warx04/Mevtrap-POC/ and https://github.com/AlexanderBaschuk/min-unique-game. Also use these to understand what the proof-of-concept (PoC) trap contracts in this folder is all about knowing we are building it currently on the Ethereum Hoodi Network that can be tested and verified without the use of dApp but verified transactions that are recorded on the blockchain.

Ensure this folder is built identically to the "my-drosera-trap" folder in my root directory and ensure it has a readme.md after we have ensured it was built correctly.

Also ensure you make the edits below to the contracts where necessary as this was also the feedback the team gave me when I initially submitted just both contracts.

Response from Team
---
Great job, your trap are well thought-out, but there are some minor issues and some improvements needed to fully meet your readme description.


point 1. Balance Monitoring (ERC-20 vs. ETH Balance)
Currently:

```
uint256 tokenBalance = trackedAddress.balance; ```
.balance returns the ETH balance of the address, not the balance of an ERC-20 token.

For ERC-20 monitoring, you need:

solidity
```
IERC20(tokenAddress).balanceOf(trackedAddress);```

You’ll need an IERC20 interface:

solidity
```
interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}```

Fix: Add a constant or immutable tokenAddress to track the correct ERC-20 token.

2. Price Feed
Currently:

solidity
```
int256 mockPrice = 2000e8; // Mock: replace with real Chainlink price feed```

To properly implement this, use Chainlink's AggregatorV3Interface:

solidity
```
(, int256 price,,,) = AggregatorV3Interface(priceFeed).latestRoundData();```

You need:

solidity
```
import " @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";```

And a constant:

solidity
```
AggregatorV3Interface public constant priceFeed = AggregatorV3Interface(0x...);```

3. Logical Condition: "Both thresholds are crossed"
Your current condition:

solidity
```
bool triggered = (balanceDiff > BALANCE_THRESHOLD) || (priceDiff > PRICE_THRESHOLD);```

This will trigger if either balance or price changes.

Requirement says: both thresholds must be crossed.

Fix:

solidity
```
bool triggered = (balanceDiff > BALANCE_THRESHOLD) && (priceDiff > PRICE_THRESHOLD);```

4. Whitelist Enforcement
The requirement says:

"Only addresses on the whitelist can operate this trap."

Currently, there’s no whitelist check in `collect()` or `shouldRespond()`.

You could add:

solidity
```
mapping(address => bool) public whitelist;

modifier onlyWhitelisted() {
    require(whitelist[msg.sender], "Not whitelisted");
    _;
}```

Then apply:

solidity
```
function collect() external view override onlyWhitelisted returns (bytes memory) { ... }```

Example of revived trap fixed to learn from: 

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ITrap} from "drosera-contracts/interfaces/ITrap.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
}

interface AggregatorV3Interface {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

/// @notice ERC20 Whale Trap — monitors token balance + price feed changes
contract ERC20WhaleTrap is ITrap {
    address public constant trackedAddress = 0xF38eED066703d093B20Be0A9D9fcC8684F64cdc4;
    IERC20 public constant token = IERC20(0x...); // ERC20 token address
    AggregatorV3Interface public constant priceFeed = AggregatorV3Interface(0x...); // Chainlink feed

    uint256 public constant BALANCE_THRESHOLD = 1000 * 1e18; // adjust decimals
    int256 public constant PRICE_THRESHOLD = 50e8;           // adjust decimals

    // Optional whitelist
    mapping(address => bool) public whitelist;

    constructor() {
        whitelist[msg.sender] = true; // initial whitelisted operator
    }

    modifier onlyWhitelisted() {
        require(whitelist[msg.sender], "Not whitelisted");
        _;
    }

    function collect() external view override onlyWhitelisted returns (bytes memory) {
        uint256 tokenBalance = token.balanceOf(trackedAddress);
        (, int256 price,,,) = priceFeed.latestRoundData();
        return abi.encode(trackedAddress, tokenBalance, price);
    }

    function shouldRespond(bytes[] calldata data) external pure override returns (bool, bytes memory) {
        if (data.length < 2) return (false, "");

        (address tracked0, uint256 balance0, int256 price0) = abi.decode(data[0], (address, uint256, int256));
        (address tracked1, uint256 balance1, int256 price1) = abi.decode(data[1], (address, uint256, int256));

        uint256 balanceDiff = balance1 > balance0 ? balance1 - balance0 : balance0 - balance1;
        int256 priceDiff = abs(price1 - price0);

        bool triggered = (balanceDiff > BALANCE_THRESHOLD) && (priceDiff > PRICE_THRESHOLD);

        if (triggered) {
            return (true, abi.encode(tracked1, balance0, balance1, price0, price1));
        }

        return (false, "");
    }

    function abs(int256 x) internal pure returns (int256) {
        return x >= 0 ? x : -x;
    }
}```
---
End of response

also make sure to build this folder with all it requires to be a fully tested project that can eventually be utilized on mainnet. You should also understand that the hoodi network may not have certain things or tokens like for example usdt contract addresses that maybe it can attempt to watch and as such we have to create ours that the contract can now watch. we must hardcode any variable or probably otherwise known as contract addresses that would make this system work as we won't be able to initialize these or use constructor arguments which drosera doesn't allow when deploying the main contract with the drosera tools.

Also know that when it comes to deploying the contracts, we can deploy using foundry, every other contract needed to make this project fully work including the response contract (ERC20WhaleResponse.sol) exempting the main contract (ERC20WhaleTrap.sol) which would only be deployed using drosera CLI commands.

Now taking these into note also know that this folder would have to be pushed into a git repo as I have already configured the folder to use the email & username for the GitHub I will be publishing to.